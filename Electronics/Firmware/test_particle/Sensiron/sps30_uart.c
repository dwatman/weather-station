/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 1.3.3
 * Product:       sps30
 * Model-Version: 1.0.1
 */
/*
 * Copyright (c) 2025, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "sps30_uart.h"
#include "sensirion_common.h"
#include "sensirion_shdlc.h"

static uint8_t communication_buffer[44] = {0};
extern volatile uint32_t timeout;

/*
int16_t sps30_wake_up_sequence() {
    int16_t local_error = 0;
    local_error = sps30_wake_up_communication();
    if (local_error != NO_ERROR) {
        return local_error;
    }
    local_error = sps30_wake_up();
    if (local_error != NO_ERROR) {
        return local_error;
    }
    return local_error;
}

int16_t sps30_start_measurement(sps30_output_format measurement_output_format) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x0, SPS30_SHDLC_ADDR, 2);
    sensirion_add_uint16_t_argument(&stream, measurement_output_format);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}

int16_t sps30_stop_measurement() {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x1, SPS30_SHDLC_ADDR, 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}

int16_t sps30_read_measurement_values_uint16(
    uint16_t* mc_1p0, uint16_t* mc_2p5, uint16_t* mc_4p0, uint16_t* mc_10p0,
    uint16_t* nc_0p5, uint16_t* nc_1p0, uint16_t* nc_2p5, uint16_t* nc_4p0,
    uint16_t* nc_10p0, uint16_t* typical_particle_size) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x3, SPS30_SHDLC_ADDR, 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 20, &header, 50);
    *mc_1p0 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[0]);
    *mc_2p5 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[2]);
    *mc_4p0 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[4]);
    *mc_10p0 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[6]);
    *nc_0p5 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[8]);
    *nc_1p0 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[10]);
    *nc_2p5 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[12]);
    *nc_4p0 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[14]);
    *nc_10p0 = sensirion_common_bytes_to_uint16_t(&buffer_ptr[16]);
    *typical_particle_size =
        sensirion_common_bytes_to_uint16_t(&buffer_ptr[18]);
    return local_error;
}

int16_t sps30_read_measurement_values_float(float* mc_1p0, float* mc_2p5,
                                            float* mc_4p0, float* mc_10p0,
                                            float* nc_0p5, float* nc_1p0,
                                            float* nc_2p5, float* nc_4p0,
                                            float* nc_10p0,
                                            float* typical_particle_size) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x3, SPS30_SHDLC_ADDR, 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 40, &header, 50);
    *mc_1p0 = sensirion_common_bytes_to_float(&buffer_ptr[0]);
    *mc_2p5 = sensirion_common_bytes_to_float(&buffer_ptr[4]);
    *mc_4p0 = sensirion_common_bytes_to_float(&buffer_ptr[8]);
    *mc_10p0 = sensirion_common_bytes_to_float(&buffer_ptr[12]);
    *nc_0p5 = sensirion_common_bytes_to_float(&buffer_ptr[16]);
    *nc_1p0 = sensirion_common_bytes_to_float(&buffer_ptr[20]);
    *nc_2p5 = sensirion_common_bytes_to_float(&buffer_ptr[24]);
    *nc_4p0 = sensirion_common_bytes_to_float(&buffer_ptr[28]);
    *nc_10p0 = sensirion_common_bytes_to_float(&buffer_ptr[32]);
    *typical_particle_size = sensirion_common_bytes_to_float(&buffer_ptr[36]);
    return local_error;
}

int16_t sps30_sleep() {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x10, SPS30_SHDLC_ADDR,
                                 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}

int16_t sps30_wake_up_communication() {
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0xff, SPS30_SHDLC_ADDR,
                                 0);
    sensirion_shdlc_write_request(&stream);
    return local_error;
}

int16_t sps30_wake_up() {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x11, SPS30_SHDLC_ADDR,
                                 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}

int16_t sps30_start_fan_cleaning() {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x56, SPS30_SHDLC_ADDR,
                                 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}

int16_t sps30_read_auto_cleaning_interval(uint32_t* auto_cleaning_interval) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x80, SPS30_SHDLC_ADDR,
                                 1);
    sensirion_add_uint8_t_argument(&stream, 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 4, &header, 50);
    *auto_cleaning_interval =
        sensirion_common_bytes_to_uint32_t(&buffer_ptr[0]);
    return local_error;
}

int16_t sps30_write_auto_cleaning_interval(uint32_t auto_cleaning_interval) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0x80, SPS30_SHDLC_ADDR,
                                 5);
    sensirion_add_uint8_t_argument(&stream, 0);
    sensirion_add_uint32_t_argument(&stream, auto_cleaning_interval);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}

int16_t sps30_read_product_type(int8_t* product_type,
                                uint16_t product_type_size) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0xd0, SPS30_SHDLC_ADDR,
                                 1);
    sensirion_add_uint8_t_argument(&stream, 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 9, &header, 50);
    sensirion_common_copy_bytes(&buffer_ptr[0], (uint8_t*)product_type,
                                product_type_size);
    return local_error;
}

int16_t sps30_read_serial_number(int8_t* serial_number,
                                 uint16_t serial_number_size) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0xd0, SPS30_SHDLC_ADDR,
                                 1);
    sensirion_add_uint8_t_argument(&stream, 3);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 32, &header, 50);
    sensirion_common_copy_bytes(&buffer_ptr[0], (uint8_t*)serial_number,
                                serial_number_size);
    return local_error;
}

int16_t sps30_read_version(uint8_t* firmware_major_version,
                           uint8_t* firmware_minor_version, uint8_t* reserved1,
                           uint8_t* hardware_revision, uint8_t* reserved2,
                           uint8_t* shdlc_major_version,
                           uint8_t* shdlc_minor_version) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0xd1, SPS30_SHDLC_ADDR,
                                 0);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 7, &header, 50);
    *firmware_major_version = (uint8_t)buffer_ptr[0];
    *firmware_minor_version = (uint8_t)buffer_ptr[1];
    *reserved1 = (uint8_t)buffer_ptr[2];
    *hardware_revision = (uint8_t)buffer_ptr[3];
    *reserved2 = (uint8_t)buffer_ptr[4];
    *shdlc_major_version = (uint8_t)buffer_ptr[5];
    *shdlc_minor_version = (uint8_t)buffer_ptr[6];
    return local_error;
}

int16_t sps30_read_device_status_register(bool clear_status_register,
                                          uint32_t* device_status_register,
                                          uint8_t* reserved) {
    struct sensirion_shdlc_rx_header header;
    sensirion_streaming_state stream;
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0xd2, SPS30_SHDLC_ADDR,
                                 1);
    sensirion_add_bool_argument(&stream, clear_status_register);
    local_error = sensirion_shdlc_write_request(&stream);
    if (local_error) {
        return local_error;
    }
    local_error = sensirion_shdlc_read_response(&stream, 5, &header, 50);
    *device_status_register =
        sensirion_common_bytes_to_uint32_t(&buffer_ptr[0]);
    *reserved = (uint8_t)buffer_ptr[4];
    return local_error;
}
*/
int16_t sps30_device_reset() {
    int16_t local_error = NO_ERROR;
    uint8_t* buf = communication_buffer;
    //sensirion_shdlc_begin_stream(&stream, buffer_ptr, 0xd3, SPS30_SHDLC_ADDR, 0);
    //local_error = sensirion_shdlc_write_request(&stream);

    sensirion_shdlc_tx(SPS30_SHDLC_ADDR, SPS30_DEVICE_RESET_CMD_ID, 0, buf);

    if (local_error) {
        return local_error;
    }
    //local_error = sensirion_shdlc_read_response(&stream, 0, &header, 50);
    return local_error;
}
