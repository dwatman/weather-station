/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 1.3.3
 * Product:       sps30
 * Model-Version: 1.0.1
 */
/*
 * Copyright (c) 2025, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SPS30_UART_H
#define SPS30_UART_H

#include <stdint.h>
#include <stdbool.h>

#include "usart_dma.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SPS30_SHDLC_ADDR 0x00

typedef enum {
    SPS30_START_MEASUREMENT_CMD_ID = 0x0,
    SPS30_STOP_MEASUREMENT_CMD_ID = 0x1,
    SPS30_READ_MEASUREMENT_VALUES_UINT16_CMD_ID = 0x3,
    SPS30_READ_MEASUREMENT_VALUES_FLOAT_CMD_ID = 0x3,
    SPS30_SLEEP_CMD_ID = 0x10,
    SPS30_WAKE_UP_COMMUNICATION_CMD_ID = 0xff,
    SPS30_WAKE_UP_CMD_ID = 0x11,
    SPS30_START_FAN_CLEANING_CMD_ID = 0x56,
    SPS30_READ_AUTO_CLEANING_INTERVAL_CMD_ID = 0x80,
    SPS30_WRITE_AUTO_CLEANING_INTERVAL_CMD_ID = 0x80,
    SPS30_READ_PRODUCT_TYPE_CMD_ID = 0xd0,
    SPS30_READ_SERIAL_NUMBER_CMD_ID = 0xd0,
    SPS30_READ_VERSION_CMD_ID = 0xd1,
    SPS30_READ_DEVICE_STATUS_REGISTER_CMD_ID = 0xd2,
    SPS30_DEVICE_RESET_CMD_ID = 0xd3,
} SPS30_CMD_ID;

typedef enum {
    SPS30_OUTPUT_FORMAT_OUTPUT_FORMAT_FLOAT = 259,
    SPS30_OUTPUT_FORMAT_OUTPUT_FORMAT_UINT16 = 261,
} sps30_output_format;

typedef struct {
	float mc_1p0;
	float mc_2p5;
	float mc_4p0;
	float mc_10p0;
	float nc_0p5;
	float nc_1p0;
	float nc_2p5;
	float nc_4p0;
	float nc_10p0;
	float typ_sz;
	char new_data;
} sensirion_sps30_data_t;

int16_t sps30_receive(uart_dma_rx_t *rx, sensirion_sps30_data_t *spsdata);

/**
 * @brief Fully wake up the device
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_wake_up_sequence();

/**
 * @brief Start measurement
 *
 * Starts the measurement. After power up, the module is in Idle-Mode. Before
 * any measurement values can be read, the Measurement-Mode needs to be started
 * using this command.
 *
 * @param[in] measurement_output_format Possible enum values:
 * output_format_float, output_format_uint16
 *
 * @note This command can only be executed in Idle-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 *
 * Example:
 * --------
 *
 * @code{.c}
 *
 *     int16_t local_error = 0;
 *     local_error = sps30_start_measurement((sps30_output_format)(261));
 *     if (local_error != NO_ERROR) {
 *         return local_error;
 *     }
 *
 * @endcode
 *
 */
int16_t sps30_start_measurement(uart_dma_tx_t *tx, sps30_output_format measurement_output_format);

/**
 * @brief Stop measurement
 *
 * Use this command to return to the Idle-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_stop_measurement(uart_dma_tx_t *tx);

int16_t sps30_read_measurement_values(uart_dma_tx_t *tx);

/**
 * @brief Read measurement values
 *
 * Reads the measured values from the module. If no new measurement values are
 * available, the module returns an empty response frame.
 *
 * @param[out] mc_1p0 Mass Concentration PM1.0 [µg/m³]
 * @param[out] mc_2p5 Mass Concentration PM2.5 [µg/m³]
 * @param[out] mc_4p0 Mass Concentration PM4.0 [µg/m³]
 * @param[out] mc_10p0 Mass Concentration PM10.0 [µg/m³]
 * @param[out] nc_0p5 Number Concentration PM0.5 [#/cm³]
 * @param[out] nc_1p0 Number Concentration PM1.0 [#/cm³]
 * @param[out] nc_2p5 Number Concentration PM2.5 [#/cm³]
 * @param[out] nc_4p0 Number Concentration PM4.0 [#/cm³]
 * @param[out] nc_10p0 Number Concentration PM10.0 [#/cm³]
 * @param[out] typical_particle_size Typical Particle Size [µm]
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_measurement_values_uint16(
    uint16_t* mc_1p0, uint16_t* mc_2p5, uint16_t* mc_4p0, uint16_t* mc_10p0,
    uint16_t* nc_0p5, uint16_t* nc_1p0, uint16_t* nc_2p5, uint16_t* nc_4p0,
    uint16_t* nc_10p0, uint16_t* typical_particle_size);

/**
 * @brief Read measurement values
 *
 * Reads the measured values from the module. If no new measurement values are
 * available, the module returns an empty response frame.
 *
 * @param[out] mc_1p0 Mass Concentration PM1.0 [µg/m³]
 * @param[out] mc_2p5 Mass Concentration PM2.5 [µg/m³]
 * @param[out] mc_4p0 Mass Concentration PM4.0 [µg/m³]
 * @param[out] mc_10p0 Mass Concentration PM10.0 [µg/m³]
 * @param[out] nc_0p5 Number Concentration PM0.5 [#/cm³]
 * @param[out] nc_1p0 Number Concentration PM1.0 [#/cm³]
 * @param[out] nc_2p5 Number Concentration PM2.5 [#/cm³]
 * @param[out] nc_4p0 Number Concentration PM4.0 [#/cm³]
 * @param[out] nc_10p0 Number Concentration PM10.0 [#/cm³]
 * @param[out] typical_particle_size Typical Particle Size [µm]
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_measurement_values_float(float* mc_1p0, float* mc_2p5,
                                            float* mc_4p0, float* mc_10p0,
                                            float* nc_0p5, float* nc_1p0,
                                            float* nc_2p5, float* nc_4p0,
                                            float* nc_10p0,
                                            float* typical_particle_size);

/**
 * @brief sps30_sleep
 *
 * Enters the Sleep-Mode with minimum power consumption. This will also
 * deactivate the UART interface.
 *
 * @note This command can only be executed in Idle-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_sleep();

/**
 * @brief sps30_wake_up_communication
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_wake_up_communication();

/**
 * @brief sps30_wake_up
 *
 * Use this command to switch from Sleep-Mode to Idle-Mode. In Sleep-Mode the
 * UART interface is disabled and must first be activated by sending a low pulse
 * on the RX pin. This pulse is generated by sending a single byte with the
 * value 0xFF. If then a Wake-up command follows within 100ms, the module will
 * switch on again and is ready for further commands in the Idle-Mode.
 *
 * Alternatively, if the software implementation does not allow to send a single
 * byte with the value 0xFF, the Wake-up command can be sent twice in
 * succession. In this case the first Wake-up command is ignored, but causes the
 * interface to be activated.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_wake_up();

/**
 * @brief Starts fan cleaning manually
 *
 * @note This command can only be executed in Measurement-Mode.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_start_fan_cleaning();

/**
 * @brief Reads auto cleaning interval of the periodic fan-cleaning
 *
 * @param[out] auto_cleaning_interval Interval in seconds
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_auto_cleaning_interval(uint32_t* auto_cleaning_interval);

/**
 * @brief Writes auto cleaning interval of the periodic fan-cleaning
 *
 * @param[in] auto_cleaning_interval Interval in seconds
 *
 * @return error_code 0 on success, an error code otherwise.
 *
 * Example:
 * --------
 *
 * @code{.c}
 *
 *     int16_t local_error = 0;
 *     local_error = sps30_write_auto_cleaning_interval(604800);
 *     if (local_error != NO_ERROR) {
 *         return local_error;
 *     }
 *
 * @endcode
 *
 */
int16_t sps30_write_auto_cleaning_interval(uint32_t auto_cleaning_interval);

/**
 * @brief Read product type
 *
 * This command returns the product type. It is defined as a string value with a
 * length of 8 ASCII characters (excluding terminating null-character)
 *
 * @param[out] product_type 8-byte ASCII string + null-character
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_product_type(int8_t* product_type,
                                uint16_t product_type_size);

/**
 * @brief Read serial number
 *
 * This command returns the serial number. It is defined as a string value with
 * a maximum length of 32 ASCII characters (including terminating
 * null-character)
 *
 * @param[out] serial_number 32-byte ASCII string
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_serial_number(int8_t* serial_number,
                                 uint16_t serial_number_size);

/**
 * @brief Gets version information about the firmware, hardware, and SHDLC
 * protocol.
 *
 * @param[out] firmware_major_version
 * @param[out] firmware_minor_version
 * @param[out] reserved1
 * @param[out] hardware_revision
 * @param[out] reserved2
 * @param[out] shdlc_major_version
 * @param[out] shdlc_minor_version
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_version(uint8_t* firmware_major_version,
                           uint8_t* firmware_minor_version, uint8_t* reserved1,
                           uint8_t* hardware_revision, uint8_t* reserved2,
                           uint8_t* shdlc_major_version,
                           uint8_t* shdlc_minor_version);

/**
 * @brief Reads device status register
 *
 * Use this command to read the device status register. For more details, check
 * explanations given in chapter 4.4 of the datasheet.
 *
 * @param[in] clear_status_register To clear the status register after reading
 * set to true, otherwise set to false.
 * @param[out] device_status_register
 * @param[out] reserved
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_read_device_status_register(bool clear_status_register,
                                          uint32_t* device_status_register,
                                          uint8_t* reserved);

/**
 * @brief Device software reset
 *
 * Device software reset command. After calling this command, the module is in
 * the same state as after a power reset.
 *
 * @note To perform a reset when the sensor is in sleep mode, it is required to
 * send first a wake-up sequence to activate the interface.
 *
 * @return error_code 0 on success, an error code otherwise.
 */
int16_t sps30_device_reset(uart_dma_tx_t *tx);

#ifdef __cplusplus
}
#endif
#endif  // SPS30_UART_H
